<html>
  
<head>
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>

  <body>
 <a-scene cursor="rayOrigin: mouse" raycaster="objects: .fork-menu-button"
         keyboard-shortcuts="" screenshot="" xr-mode-ui="">
  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">


  <!-- Tree models -->
  <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
  <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
  <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
  <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
    
</a-assets>
  

  <!-- Ground -->
  <a-plane rotation="-90 0 0" width="50" height="50"
           material="repeat: 20 20; shader: flat; src: #groundTexture"></a-plane>

  <!-- Intro vertical -->
  <a-box width="1.5" height="0.05" depth="8"
         position="0 0.025 12.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork horizontal -->
  <a-box width="7" height="0.05" depth="1.5"
         position="0 0.03943 8.75"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Branches -->
  <a-box class="left-branch" width="1.5" height="0.05" depth="14"
         position="-2.76655 0.025 1.00951"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="middle-branch" width="1.5" height="0.05" depth="14"
         position="0 0.025 1.03888"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="right-branch" width="1.5" height="0.05" depth="14"
         position="2.737 0.025 1.01381"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>

  <!-- Ending straight -->
  <a-box width="7" height="0.05" depth="1.5"
         position="0 0.03169 -6.25"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Final straight to castle -->
  <a-box width="1.5" height="0.05" depth="8"
         position="0 0.025 -10.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu (HUD) -->
  <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left"
           position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle"
           width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right"
           position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-box id="castle" position="0 0.5 -15"
         width="2" height="2" depth="2" color="gold"></a-box>

  <!-- Player -->
<a-entity id="rig" position="0 0.5 16" player-movement="movementMode: camera">
  <a-entity camera look-controls></a-entity>
</a-entity>


  <!-- Tree placeholders -->
  <a-entity id="trees"></a-entity>

  <!-- Script -->
<!-- All scene elements (ground, paths, branches, trees, player, forkMenu, castle) -->

<!-- Single script at the end -->
<script>
AFRAME.registerComponent('player-movement', {
  schema: {
    // 'world' (default) -> arrow keys / WASD move along world X/Z axes
    // 'camera' -> arrow keys / WASD move relative to camera forward/right
    movementMode: { type: 'string', default: 'world' }
  },

  init: function() {
    const rig = this.el;

    // initial bounds before choice (allows player to move up to the fork)
    this.currentBounds = { xMin: -0.75, xMax: 0.75, zMin: -15, zMax: 16.75 };
    this.choiceMade = false;

    // normalized key map (all lowercase)
    this.keys = {
      w: false, a: false, s: false, d: false,
      arrowup: false, arrowdown: false, arrowleft: false, arrowright: false
    };

    // Key handlers (normalize to lowercase: 'arrowup' / 'w' / 'a' etc.)
    window.addEventListener('keydown', (e) => {
      const k = (e.key || '').toLowerCase();
      if (k in this.keys) {
        this.keys[k] = true;
        e.preventDefault(); // prevent page scrolling / default behavior
      }
    });
    window.addEventListener('keyup', (e) => {
      const k = (e.key || '').toLowerCase();
      if (k in this.keys) {
        this.keys[k] = false;
        e.preventDefault();
      }
    });

    // Fork menu clicks: lock a corridor for the chosen path and block the others (entry + exit)
    document.querySelectorAll('.fork-menu-button').forEach(btn => {
      btn.addEventListener('click', () => {
        if (this.choiceMade) return; // ignore extra clicks
        const choice = btn.getAttribute('data-choice');
        this.choiceMade = true;
        document.getElementById('forkMenu').setAttribute('visible', false);

        // Expand the chosen corridor all the way to the castle (zMin:-15 allows reaching the castle)
        if (choice === 'left') {
          this.currentBounds = { xMin: -3.0, xMax: -2.0, zMin: -15, zMax: 8.75 };
        } else if (choice === 'middle') {
          this.currentBounds = { xMin: -0.75, xMax: 0.75, zMin: -15, zMax: 8.75 };
        } else if (choice === 'right') {
          this.currentBounds = { xMin: 2.0, xMax: 3.0, zMin: -15, zMax: 8.75 };
        }

        // Add invisible blocking walls for unchosen paths (both entry and exit)
        const scene = document.querySelector('a-scene');
        const pathX = { left: -2.8, middle: 0, right: 2.8 };

        ['left', 'middle', 'right'].forEach(path => {
          if (path === choice) return;
          // entry wall (front)
          const entryWall = document.createElement('a-box');
          entryWall.setAttribute('position', `${pathX[path]} 1 8.5`); // front of branch
          entryWall.setAttribute('width', '1.5');
          entryWall.setAttribute('height', '2');
          entryWall.setAttribute('depth', '0.5');
          entryWall.setAttribute('opacity', '0');
          entryWall.setAttribute('class', 'invisible-block');
          scene.appendChild(entryWall);

          // exit wall (back)
          const exitWall = document.createElement('a-box');
          exitWall.setAttribute('position', `${pathX[path]} 1 -6.5`); // back of branch
          exitWall.setAttribute('width', '1.5');
          exitWall.setAttribute('height', '2');
          exitWall.setAttribute('depth', '0.5');
          exitWall.setAttribute('opacity', '0');
          exitWall.setAttribute('class', 'invisible-block');
          scene.appendChild(exitWall);
        });
      });
    });
  },

  tick: function() {
    const rig = this.el;
    const rigObj = rig.object3D;
    const speed = 0.03;

    // position as three.js vector (faster and avoids attribute overhead)
    const pos = rigObj.position;

    // Show fork menu at fork: force player's z to fork line until choice is made
    if (!this.choiceMade && pos.z <= 8.75) {
      pos.z = 8.75;
      rigObj.position.copy(pos);
      document.getElementById('forkMenu').setAttribute('visible', true);
      return;
    }

    // movement delta to apply this frame
    let dx = 0, dz = 0;

    if (this.data.movementMode === 'camera') {
      // camera-relative movement
      const cameraEl = rig.querySelector('[camera]');
      if (cameraEl) {
        const dir = new AFRAME.THREE.Vector3();
        cameraEl.object3D.getWorldDirection(dir); // forward vector
        dir.y = 0; // ignore vertical
        dir.normalize();

        // compute right vector (world-up x forward)
        const right = new AFRAME.THREE.Vector3();
        right.crossVectors(new AFRAME.THREE.Vector3(0, 1, 0), dir).normalize();

        if (this.keys.w || this.keys.arrowup) { dx += dir.x * speed; dz += dir.z * speed; }
        if (this.keys.s || this.keys.arrowdown) { dx -= dir.x * speed; dz -= dir.z * speed; }
        if (this.keys.a || this.keys.arrowleft) { dx -= right.x * speed; dz -= right.z * speed; }
        if (this.keys.d || this.keys.arrowright) { dx += right.x * speed; dz += right.z * speed; }
      }
    } else {
      // world-relative movement (default) â€” Up always decreases z in world coords
      if (this.keys.w || this.keys.arrowup) dz -= speed;
      if (this.keys.s || this.keys.arrowdown) dz += speed;
      if (this.keys.a || this.keys.arrowleft) dx -= speed;
      if (this.keys.d || this.keys.arrowright) dx += speed;
    }

    // apply movement
    pos.x += dx;
    pos.z += dz;

    // Determine bounds.
    // IMPORTANT: once a choice has been made, keep using the chosen path bounds for ALL z
    // so the other paths remain out of limits entirely (cannot enter from entry or exit).
    let bounds;
    if (this.choiceMade) {
      bounds = this.currentBounds;
    } else {
      // before choice, keep the earlier behavior where final area merges paths
      if (pos.z > -6) {
        bounds = this.currentBounds;
      } else {
        bounds = { xMin: -3.5, xMax: 3.5, zMin: -15, zMax: 8.75 };
      }
    }

    // clamp to bounds
    pos.x = Math.max(bounds.xMin, Math.min(bounds.xMax, pos.x));
    pos.z = Math.max(bounds.zMin, Math.min(bounds.zMax, pos.z));

    // write back
    rigObj.position.copy(pos);
  }
});

// --- Tree scattering (unchanged except kept here) ---
const trees = document.getElementById('trees');
const treeTypes = ['tree1','tree2','tree3','tree4'];

// Function to prevent trees from spawning on paths
function inPath(x,z){
  const pathBounds = [
    {x:0, z:[9,17]}, {x:[-3.5,3.5], z:[8,10]}, {x:-2.8, z:[-6,9]},
    {x:0, z:[-6,9]}, {x:2.8, z:[-6,9]}, {x:[-3.5,3.5], z:[-7,-6]},
    {x:0, z:[-15,-10]}
  ];
  return pathBounds.some(b => {
    if(Array.isArray(b.x) && Array.isArray(b.z)) return x>=b.x[0]&&x<=b.x[1] && z>=b.z[0]&&z<=b.z[1];
    if(Array.isArray(b.x)) return x>=b.x[0]&&x<=b.x[1] && z>=b.z[0]&&z<=b.z[1];
    if(Array.isArray(b.z)) return Math.abs(x-b.x)<1 && z>=b.z[0]&&z<=b.z[1];
  });
}

// Scatter trees
for(let i=0; i<150; i++){
  let x = (Math.random()-0.5)*50;
  let z = (Math.random()-0.5)*50;
  if(inPath(x,z)) continue;

  const type = treeTypes[Math.floor(Math.random()*treeTypes.length)];
  let scale = 0.01 + Math.random()*0.02; // random scale for variety
  if(type==='tree4') scale *= 30; // make tree4 bigger by default

  const rotY = Math.random()*360;
  let tree = document.createElement('a-entity');
  tree.setAttribute('gltf-model', `#${type}`);
  tree.setAttribute('position', `${x} 0 ${z}`);
  tree.setAttribute('scale', `${scale} ${scale} ${scale}`);
  tree.setAttribute('rotation', `0 ${rotY} 0`);
  trees.appendChild(tree);
}
</script>




</a-scene>


  </body>
</html> 
