<html>
<head>
  <meta charset="utf-8" />
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
<a-scene cursor="rayOrigin: mouse" raycaster="objects: .fork-menu-button" keyboard-shortcuts="">

  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">
    <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
    <a-asset-item id="goblin" src="assets/goblin_mob.glb"></a-asset-item>
        <a-asset-item id="fairy1" src="assets/fairy_gm_villager1.glb"></a-asset-item>
     <a-asset-item id="fairy2" src="assets/fairy_gm_villager3.glb"></a-asset-item>
     <a-asset-item id="fairy3" src="assets/fairy_gm_villager4.glb"></a-asset-item>
     <a-asset-item id="fairy4" src="assets/fairy_gm_villager5.glb"></a-asset-item>
     <a-asset-item id="fairy5" src="assets/fairy_gm_villager6.glb"></a-asset-item>
  </a-assets>

  <!-- Ground -->
  <a-plane rotation="-90 0 0" width="50" height="50"
           material="repeat: 20 20; shader: flat; src: #groundTexture"></a-plane>

  <!-- Paths -->
  <a-box width="1.5" height="0.05" depth="8" position="0 0.025 12.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03943 8.75"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box class="left-branch" width="1.5" height="0.05" depth="14" position="-2.76655 0.025 1.00951"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="middle-branch" width="1.5" height="0.05" depth="14" position="0 0.025 1.03888"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="right-branch" width="1.5" height="0.05" depth="14" position="2.737 0.025 1.01381"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03169 -6.25"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box width="1.5" height="0.05" depth="8" position="0 0.025 -10.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu -->
  <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left" position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle" width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right" position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-box id="castle" position="0 0.5 -15" width="2" height="2" depth="2" color="gold"></a-box>

  <!-- Player rig -->
  <a-entity id="rig" position="0 0.5 16" player-movement>
    <a-entity camera look-controls></a-entity>
  </a-entity>

  <!-- Tree holder -->
  <a-entity id="trees"></a-entity>

<a-entity id="fairies">
  <a-entity gltf-model="#fairy1" position="3.8 0.97 7" scale="0.1 0.1 0.1"
    rotation="0 135 0"
            fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2">
  </a-entity>

  <a-entity gltf-model="#fairy2" position="3.7 0.95 7.2" scale="0.1 0.1 0.1"
    rotation="0 130 0"
            fairy-behavior="idleAnim:idle; reactAnim:interact2; reactDistance:2">
  </a-entity>

  <a-entity gltf-model="#fairy3" position="3.6 0.85 7.1" scale="0.1 0.1 0.1"
    rotation="0 140 0"
            fairy-behavior="idleAnim:idle; reactAnim:cantar; reactDistance:2">
  </a-entity>

  <a-entity gltf-model="#fairy4" position="3.85 0.8 7.3" scale="0.1 0.1 0.1"
    rotation="0 132 0"
            fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2">
  </a-entity>

  <a-entity gltf-model="#fairy5" position="3.65 1 7.15" scale="0.1 0.1 0.1"
    rotation="0 137 0"
            fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2">
  </a-entity>
</a-entity>

  <!-- Goblin -->
  <a-entity gltf-model="#goblin" position="2.5 0 -4" scale="0.3 0.3 0.3"
            goblin-behavior="walkIndex:0; lookDistance:4; startWalkDistance:1.6; speed:1.2">
  </a-entity>

<script>
/* -----------------------
   Player movement
----------------------- */
AFRAME.registerComponent('player-movement', {
  init: function () {
    this.choiceMade = false;
    this.chosenPath = null;
    this.followingGoblin = false;
    this.keys = {ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false};
    const scene = this.el.sceneEl;

    window.addEventListener('keydown', e=>{ if(this.keys.hasOwnProperty(e.key)) this.keys[e.key]=true; });
    window.addEventListener('keyup', e=>{ if(this.keys.hasOwnProperty(e.key)) this.keys[e.key]=false; });

    scene.querySelectorAll('.fork-menu-button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        this.chosenPath = btn.getAttribute('data-choice');
        this.choiceMade = true;
        document.getElementById('forkMenu').setAttribute('visible', false);
        scene.querySelectorAll('.fork-menu-button').forEach(b=>b.classList.remove('fork-menu-button'));
        const cursorEl = scene.querySelector('[cursor]');
        if(cursorEl && cursorEl.components && cursorEl.components.raycaster)
          cursorEl.components.raycaster.data.objects = '';
      });
      btn.setAttribute('material','depthTest:false;');
      btn.object3D.renderOrder=999;
    });
  },
  tick: function () {
    const rig = this.el;
    let pos = rig.getAttribute('position');
    const speed = 0.025;

    // Fork menu enforcement
    if(!this.choiceMade && pos.z <= 8.75){
      pos.z = 8.75; rig.setAttribute('position', pos);
      document.getElementById('forkMenu').setAttribute('visible', true);
      return;
    }

    // camera-relative movement
    const camera = this.el.sceneEl.camera.el.object3D;
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y=0; camDir.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();
    let dx=0,dz=0;
    if(this.keys.ArrowUp){ dx-=camDir.x*speed; dz-=camDir.z*speed; }
    if(this.keys.ArrowDown){ dx+=camDir.x*speed; dz+=camDir.z*speed; }
    if(this.keys.ArrowLeft){ dx-=right.x*speed; dz-=right.z*speed; }
    if(this.keys.ArrowRight){ dx+=right.x*speed; dz+=right.z*speed; }

    pos.x += dx; pos.z += dz;

    // Bounds
    let bounds;
    if(!this.choiceMade){
      bounds={xMin:-0.75,xMax:0.75,zMin:-15,zMax:16.75};
    } else if(pos.z<=8.75 && pos.z>-6){
      if(this.chosenPath==='left') bounds={xMin:-3.3,xMax:-2.3,zMin:-6.25,zMax:8.75};
      else if(this.chosenPath==='middle') bounds={xMin:-0.75,xMax:0.75,zMin:-6.25,zMax:8.75};
      else if(this.chosenPath==='right' && !this.followingGoblin) bounds={xMin:2.2,xMax:3.2,zMin:-6.25,zMax:8.75};
      else bounds={xMin:-25,xMax:25,zMin:-25,zMax:25};
    } else bounds={xMin:-25,xMax:25,zMin:-25,zMax:25};

    pos.x = Math.max(bounds.xMin, Math.min(bounds.xMax,pos.x));
    pos.z = Math.max(bounds.zMin, Math.min(bounds.zMax,pos.z));
    rig.setAttribute('position', pos);

    // Losing condition
    const origin = new THREE.Vector3(0,0,16);
    const playerPos = new THREE.Vector3(pos.x,pos.y,pos.z);
    if(playerPos.distanceTo(origin) > 35){
      alert('You wandered too far and got lost! Game over.');
      window.location.reload();
    }
  }
});

/* -----------------------
   Goblin behavior
----------------------- */
AFRAME.registerComponent('goblin-behavior', {
  schema: {
    walkIndex: { type: 'int', default: 0 },
    lookDistance: { type: 'number', default: 6 }, // adjust as needed
    startWalkDistance: { type: 'number', default: 1.6 },
    speed: { type: 'number', default: 1.2 }
  },

  init: function() {
    this.state = 'idle';
    this.mixer = null;
    this.walkAction = null;
    this.animations = [];
    this.modelRoot = null;
    this.hasLooked = false;
    this.walkingStarted = false;
    this.rig = document.getElementById('rig');

    // Set initial spawn direction: facing right (+X)
    this.el.addEventListener('model-loaded', (e) => {
      const gltfScene = e.detail.model;
      this.modelRoot = this.el.getObject3D('mesh') || gltfScene;
      this.animations = (gltfScene?.animations?.slice()) || [];

     if (this.modelRoot) {
  // Rotate the model so its front faces +X
  this.modelRoot.rotation.y = THREE.MathUtils.degToRad(-90);
}
this.el.object3D.rotation.set(0, 0, 0); // parent stays aligned with world axes
    });
  },

  tick: function(time, timeDelta) {
    if (!this.rig || !this.el.object3D) return;
    const gob3 = this.el.object3D;
    const rig3 = this.rig.object3D;
    const dx = rig3.position.x - gob3.position.x;
    const dz = rig3.position.z - gob3.position.z;
    const dist = Math.hypot(dx, dz);
    const dt = (timeDelta || 0) / 1000;

    if (this.mixer) try { this.mixer.update(dt); } catch (err) {}

    // 1) Look at player once when approaching
    if (this.state === 'idle' && dist <= this.data.lookDistance && !this.hasLooked) {
      const angleToPlayer = Math.atan2(rig3.position.x - gob3.position.x, rig3.position.z - gob3.position.z);
 gob3.rotation.y = angleToPlayer - THREE.MathUtils.degToRad(90);
      this.hasLooked = true;
    }

    // 2) Start walking when player very close
    if (this.state === 'idle' && dist <= this.data.startWalkDistance && !this.walkingStarted) {
     gob3.rotation.y = 0; // reset to face right (+X)
      
      if (this.modelRoot && this.animations.length > this.data.walkIndex) {
        try {
          this.mixer = new THREE.AnimationMixer(this.modelRoot);
          this.walkAction = this.mixer.clipAction(this.animations[this.data.walkIndex]);
          this.walkAction.setLoop(THREE.LoopRepeat);
          this.walkAction.play();
        } catch (err) {
          console.warn(err);
          this.mixer = null;
          this.walkAction = null;
        }
      }

      this.walkingStarted = true;
      this.state = 'walking';

      const playerComp = this.rig.components['player-movement'];
      if (playerComp) playerComp.followingGoblin = true;
    }

    // 3) Walking motion
    if (this.state === 'walking') {
      const minSeparation = 0.6;
      if (dist > minSeparation) {
        gob3.position.x += this.data.speed * dt; // move right
        this.el.setAttribute('position', `${gob3.position.x} ${gob3.position.y} ${gob3.position.z}`);
      }
    }
  }
});


/* -----------------------
   Scatter trees
----------------------- */
(function scatterTrees(){
  const trees=document.getElementById('trees');
  if(!trees) return;
  const treeTypes=['tree1','tree2','tree3','tree4'];
  const branchTreeTypes=['tree1','tree2','tree3'];

  function inPath(x,z){
    if(x>-0.9&&x<0.9&&z>8.75&&z<16.75) return true;
    if(x>-3.5&&x<3.5&&z>8&&z<9.5) return true;
    if(x>-3.3&&x<-2.3&&z>-6.25&&z<8.75) return true;
    if(x>-0.75&&x<0.75&&z>-6.25&&z<8.75) return true;
    if(x>2.3&&x<3.3&&z>-6.25&&z<8.75) return true;
    if(x>-3.5&&x<3.5&&z>-7.5&&z<-6) return true;
    if(x>-0.9&&x<0.9&&z<-6.25&&z>-15) return true;
    return false;
  }

  for(let i=0;i<380;i++){
    let x=(Math.random()-0.5)*50, z=(Math.random()-0.5)*50;
    if(inPath(x,z)) continue;
    const type=treeTypes[Math.floor(Math.random()*treeTypes.length)];
    let scale=0.01+Math.random()*0.01;
    if(type==='tree4') scale*=20; if(type==='tree3') scale*=4;
    const rotY=Math.random()*360;
    let tree=document.createElement('a-entity');
    tree.setAttribute('gltf-model',`#${type}`);
    tree.setAttribute('position',`${x} 0 ${z}`);
    tree.setAttribute('scale',`${scale} ${scale} ${scale}`);
    tree.setAttribute('rotation',`0 ${rotY} 0`);
    trees.appendChild(tree);
  }

  for(let i=0;i<150;i++){
    const z=-6+Math.random()*14;
    let x = Math.random()<0.5 ? -2.0+(Math.random()*1.0) : 1.0+(Math.random()*1.0);
    const type=branchTreeTypes[Math.floor(Math.random()*branchTreeTypes.length)];
    let scale=0.01+Math.random()*0.01; if(type==='tree3') scale*=4;
    const rotY=Math.random()*360;
    let tree=document.createElement('a-entity');
    tree.setAttribute('gltf-model',`#${type}`);
    tree.setAttribute('position',`${x} 0 ${z}`);
    tree.setAttribute('scale',`${scale} ${scale} ${scale}`);
    tree.setAttribute('rotation',`0 ${rotY} 0`);
    trees.appendChild(tree);
  }
})();

// schema
AFRAME.registerComponent('fairy-behavior', {
  schema: {
    idleAnim: {type:'string', default:'Idle'},
    reactAnim: {type:'string', default:'React'},
    reactDistance: {type:'number', default:2},
    speed: {type:'number', default:0} // optional if you want flying motion
  },
  init:function(){
    this.rig=document.getElementById('rig');
    this.modelRoot=null; this.mixer=null;
    this.currentAction=null; this.idleAction=null; this.reactAction=null;

    this.el.addEventListener('model-loaded', (e)=>{
      const gltf=e.detail.model;
      this.modelRoot=this.el.getObject3D('mesh')||gltf;
      if(!this.modelRoot) return;
      const clips=gltf.animations||[];
      this.idleAction=null; this.reactAction=null;
      clips.forEach(c=>{
        if(c.name===this.data.idleAnim) this.idleAction=c;
        if(c.name===this.data.reactAnim) this.reactAction=c;
      });
      if(this.idleAction){
        this.mixer=new THREE.AnimationMixer(this.modelRoot);
        const act=this.mixer.clipAction(this.idleAction);
        act.play();
        this.currentAction='idle';
      }
    });
  },
  tick:function(time,timeDelta){
    if(!this.rig||!this.modelRoot||!this.mixer) return;
    const pos=this.el.object3D.position;
    const rigPos=this.rig.object3D.position;
    const dist=Math.hypot(pos.x-rigPos.x,pos.z-rigPos.z);
    const dt=(timeDelta||0)/1000;

    // decide which animation
    if(dist<=this.data.reactDistance && this.reactAction && this.currentAction!=='react'){
      this.mixer.stopAllAction();
      const act=this.mixer.clipAction(this.reactAction);
      act.setLoop(THREE.LoopOnce); act.clampWhenFinished=true; act.play();
      this.currentAction='react';
    } else if(dist>this.data.reactDistance && this.idleAction && this.currentAction!=='idle'){
      this.mixer.stopAllAction();
      const act=this.mixer.clipAction(this.idleAction);
      act.setLoop(THREE.LoopRepeat); act.play();
      this.currentAction='idle';
    }

    this.mixer.update(dt);
  }
});



</script>
</a-scene>
</body>
</html>
