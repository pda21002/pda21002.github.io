<html>
<head>
  <meta charset="UTF-8" />
  <title>Three Paths Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>

// === SCENE SETUP ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,5,20);
camera.lookAt(0,0,0);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5,10,7);
scene.add(dirLight);

// === PATH MATERIALS ===
const pathMaterial = new THREE.MeshLambertMaterial({color:0xaaaaaa});

// Helper to create path planes
function makePath(w,h,x,z){
  const geo = new THREE.PlaneGeometry(w,h);
  const mesh = new THREE.Mesh(geo, pathMaterial);
  mesh.rotation.x = -Math.PI/2;
  mesh.position.set(x,0,z);
  scene.add(mesh);
  return mesh;
}

// === PATHS ===

// Main pre-fork corridor
makePath(1.5, 8, 0, 12.75);

// First horizontal connector
makePath(7, 1.5, 0, 8.75);

// Left path
makePath(1.5, 15, -2.4, 0.75);

// Middle path
makePath(1.5, 15, 0, 0.75);

// Right path
makePath(1.5, 15, 2.4, 0.75);

// Second horizontal connector
makePath(7, 1.5, 0, -6.75);

// Final straight to castle
makePath(1.5, 10, 0, -12.75);

// Castle
const castle = new THREE.Mesh(new THREE.BoxGeometry(5,5,5), new THREE.MeshLambertMaterial({color:0x888888}));
castle.position.set(0,2.5,-18);
scene.add(castle);

// === TREE GENERATION ===
function makeTree(x,z){
  const tree = new THREE.Group();
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,1), new THREE.MeshLambertMaterial({color:0x8B4513}));
  trunk.position.y = 0.5;
  tree.add(trunk);
  const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.8,8,8), new THREE.MeshLambertMaterial({color:0x228B22}));
  leaves.position.y = 1.5;
  tree.add(leaves);
  tree.position.set(x,0,z);
  scene.add(tree);
}

// Path collision checker
function inPath(x,z){
  // Pre-fork corridor
  if(x>-0.75 && x<0.75 && z>8.75 && z<16.75) return true;

  // First horizontal line
  if(x>-3.5 && x<3.5 && z>8 && z<9.5) return true;

  // Left branch
  if(x>-3.15 && x<-1.65 && z>-6.25 && z<8.75) return true;

  // Middle branch
  if(x>-0.75 && x<0.75 && z>-6.25 && z<8.75) return true;

  // Right branch
  if(x>1.65 && x<3.15 && z>-6.25 && z<8.75) return true;

  // Second horizontal line
  if(x>-3.5 && x<3.5 && z>-7.5 && z<-6) return true;

  // Castle approach
  if(x>-0.75 && x<0.75 && z<-15 && z<-10.75) return true;

  return false;
}

// Scatter trees
for(let i=0;i<400;i++){
  const x = (Math.random()-0.5)*20;
  const z = (Math.random()-1)*40;
  if(!inPath(x,z)) makeTree(x,z);
}

// === PLAYER ===
const player = {
  x:0, z:16, y:0.5,
  speed:0.025,
  keys:{}
};

// Key handlers
window.addEventListener('keydown', e=>{player.keys[e.key]=true;});
window.addEventListener('keyup', e=>{player.keys[e.key]=false;});

// === UPDATE LOOP ===
function animate(){
  requestAnimationFrame(animate);

  let dx=0, dz=0;
  const forward = new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y=0; forward.normalize();
  const right = new THREE.Vector3(forward.z,0,-forward.x);

  // Movement (fixed forward/back inversion)
  if(player.keys.ArrowUp){ dx-=forward.x*player.speed; dz-=forward.z*player.speed; }
  if(player.keys.ArrowDown){ dx+=forward.x*player.speed; dz+=forward.z*player.speed; }
  if(player.keys.ArrowLeft){ dx-=right.x*player.speed; dz-=right.z*player.speed; }
  if(player.keys.ArrowRight){ dx+=right.x*player.speed; dz+=right.z*player.speed; }

  // Update position
  player.x += dx;
  player.z += dz;

  // Camera follows
  camera.position.set(player.x,5,player.z+5);
  camera.lookAt(player.x,0,player.z-5);

  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
