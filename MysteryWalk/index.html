<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Path + Trees + Smooth Collisions</title>
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
<a-scene cursor="rayOrigin: mouse" raycaster="objects: .fork-menu-button" keyboard-shortcuts="" screenshot="" xr-mode-ui="">

  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">

    <!-- Tree models -->
    <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
  </a-assets>

  <!-- Ground -->
  <a-plane rotation="-90 0 0" width="50" height="50"
           material="repeat: 20 20; shader: flat; src: #groundTexture"></a-plane>

  <!-- Paths (make sure these visually line up with what you want) -->
  <!-- Intro vertical -->
  <a-box id="intro-vert" width="1.5" height="0.05" depth="8"
         position="0 0.025 12.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork horizontal -->
  <a-box id="fork-h" width="7" height="0.05" depth="1.5"
         position="0 0.03943 8.75"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Branches -->
  <a-box class="left-branch" width="1.5" height="0.05" depth="14"
         position="-2.76655 0.025 1.00951"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="middle-branch" width="1.5" height="0.05" depth="14"
         position="0 0.025 1.03888"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="right-branch" width="1.5" height="0.05" depth="14"
         position="2.737 0.025 1.01381"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>

  <!-- Ending straight (horizontal connector) -->
  <a-box id="end-h" width="7" height="0.05" depth="1.5"
         position="0 0.03169 -6.25"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Final straight to castle -->
  <a-box id="final-vert" width="1.5" height="0.05" depth="8"
         position="0 0.025 -10.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu (HUD) -->
  <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left"
           position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle"
           width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right"
           position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-box id="castle" position="0 0.5 -15" width="2" height="2" depth="2" color="gold"></a-box>

  <!-- Player rig -->
  <a-entity id="rig" position="0 0.5 16" player-movement>
    <a-entity camera look-controls></a-entity>
  </a-entity>

  <!-- Container for trees -->
  <a-entity id="trees"></a-entity>

  <!-- Invisible container for blockers/walls (so scene stays tidy) -->
  <a-entity id="blockers"></a-entity>

<script>
/* ======= CONFIG ======= */
const TREE_COUNT = 120;        // increase to spawn more trees
const TREE_PADDING = 2.5;      // medium padding from paths (you said medium)
const SMOOTH_FACTOR = 0.25;    // how strongly to smooth collisions (0 = instant clamp, 1 = full lerp)
                              /* lower = snappier, higher = smoother slide */

/* ======= PLAYER MOVEMENT COMPONENT ======= */
AFRAME.registerComponent('player-movement', {
  init: function() {
    // initial bounds (start on middle intro)
    this.currentBounds = { xMin: -0.75, xMax: 0.75, zMin: 8.75, zMax: 16.75 };
    this.choiceMade = false;

    this.keys = { w:false, a:false, s:false, d:false,
                  ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };

    // store previous pos for smoothing
    this.prevPos = this.el.getAttribute('position');

    // key listeners (world-relative movement)
    window.addEventListener('keydown', e => { if(this.keys[e.key] !== undefined) this.keys[e.key] = true; });
    window.addEventListener('keyup',   e => { if(this.keys[e.key] !== undefined) this.keys[e.key] = false; });

    // fork menu click handlers
    document.querySelectorAll('.fork-menu-button').forEach(btn => {
      btn.addEventListener('click', () => {
        const choice = btn.getAttribute('data-choice');
        this.choiceMade = true;
        document.getElementById('forkMenu').setAttribute('visible', false);

        // set tight bounds for chosen path (X range matches visual path width)
        if(choice === 'left') {
          this.currentBounds = { xMin:-3.05, xMax:-2.0, zMin:-15, zMax:8.75 };
        } else if(choice === 'middle') {
          this.currentBounds = { xMin:-0.75, xMax:0.75, zMin:-15, zMax:8.75 };
        } else if(choice === 'right') {
          this.currentBounds = { xMin:2.0, xMax:3.05, zMin:-15, zMax:8.75 };
        }

        // add invisible blockers at entrance and exit of unchosen paths
        const blockersContainer = document.getElementById('blockers');
        ['left','middle','right'].forEach(p => {
          if(p === choice) return;

          // entrance blocker (just before fork horizontal)
          const entrance = document.createElement('a-box');
          const entranceX = (p === 'left' ? -2.8 : (p === 'right' ? 2.8 : 0));
          entrance.setAttribute('position', `${entranceX} 0.9 8.5`);
          entrance.setAttribute('width','1.5');
          entrance.setAttribute('height','1.8');
          entrance.setAttribute('depth','0.6');
          entrance.setAttribute('material','opacity:0; transparent:true');
          blockersContainer.appendChild(entrance);

          // exit blocker (at the exit of branch, before horizontal connector)
          const exit = document.createElement('a-box');
          exit.setAttribute('position', `${entranceX} 0.9 -6.25`);
          exit.setAttribute('width','1.5');
          exit.setAttribute('height','1.8');
          exit.setAttribute('depth','0.6');
          exit.setAttribute('material','opacity:0; transparent:true');
          blockersContainer.appendChild(exit);
        });

        // add bounding walls at the final merged segment edges to keep collisions consistent
        // (only add once)
        if(!document.querySelector('#merged-left-wall')) {
          const leftWall = document.createElement('a-box');
          leftWall.setAttribute('id','merged-left-wall');
          leftWall.setAttribute('position','-3.5 1 -6.25');
          leftWall.setAttribute('width','1');
          leftWall.setAttribute('height','2');
          leftWall.setAttribute('depth','18'); // spans from z ~ -15 to 8.75
          leftWall.setAttribute('material','opacity:0; transparent:true');
          leftWall.setAttribute('rotation','0 0 0');
          blockersContainer.appendChild(leftWall);

          const rightWall = document.createElement('a-box');
          rightWall.setAttribute('id','merged-right-wall');
          rightWall.setAttribute('position','3.5 1 -6.25');
          rightWall.setAttribute('width','1');
          rightWall.setAttribute('height','2');
          rightWall.setAttribute('depth','18');
          rightWall.setAttribute('material','opacity:0; transparent:true');
          blockersContainer.appendChild(rightWall);
        }
      });
    });
  },

  tick: function() {
    const rig = this.el;
    const prev = this.prevPos;
    let pos = rig.getAttribute('position'); // current position (we will compute desired and then smooth-clamp)
    const desired = { x: pos.x, y: pos.y, z: pos.z };
    const speed = 0.025; // slower & smoother

    // fork stop
    if(!this.choiceMade && pos.z <= 8.75) {
      // forcefully stop on the fork line
      desired.z = 8.75;
      rig.setAttribute('position', desired);
      this.prevPos = desired;
      document.getElementById('forkMenu').setAttribute('visible', true);
      return;
    }

    // compute desired movement in WORLD coordinates (always same directions)
    if(this.keys.w || this.keys.ArrowUp) desired.z -= speed;
    if(this.keys.s || this.keys.ArrowDown) desired.z += speed;
    if(this.keys.a || this.keys.ArrowLeft) desired.x -= speed;
    if(this.keys.d || this.keys.ArrowRight) desired.x += speed;

    // choose which bounds apply: if before connector (z > -6) use path bounds, otherwise merged bounds
    let bounds;
    if(desired.z > -6) {
      bounds = this.currentBounds; // tight along chosen path (if choice not made, currentBounds is middle)
    } else {
      // merged segment (horizontal connector + final vertical): keep collisions so player can't stray
      bounds = { xMin: -3.25, xMax: 3.25, zMin: -15, zMax: 8.75 };
    }

    // smooth clamping (avoid instant snap)
    const clampedX = Math.max(bounds.xMin, Math.min(bounds.xMax, desired.x));
    const clampedZ = Math.max(bounds.zMin, Math.min(bounds.zMax, desired.z));

    // If desired is outside bounds, smoothly move toward clamped instead of teleporting
    const newX = (desired.x !== clampedX) ? (prev.x + (clampedX - prev.x) * SMOOTH_FACTOR) : clampedX;
    const newZ = (desired.z !== clampedZ) ? (prev.z + (clampedZ - prev.z) * SMOOTH_FACTOR) : clampedZ;

    const newPos = { x: newX, y: pos.y, z: newZ };

    rig.setAttribute('position', newPos);
    this.prevPos = newPos;
  }
});

/* ======= TREE SCATTERING ======= */
(function scatterTrees() {
  const treesEl = document.getElementById('trees');
  const treeTypes = ['tree1','tree2','tree3','tree4'];

  // define the path rectangles (these will be expanded by TREE_PADDING to keep trees away)
  const rawPathBounds = [
    { xMin: -0.75, xMax: 0.75, zMin: 9,      zMax: 17 },     // intro vertical
    { xMin: -3.5,  xMax: 3.5,  zMin: 8,      zMax: 10 },     // fork horizontal
    { xMin: -3.5,  xMax: -2.0, zMin: -6,     zMax: 9 },      // left branch (approx)
    { xMin: -1.0,  xMax: 1.0,  zMin: -6,     zMax: 9 },      // middle branch (approx)
    { xMin: 2.0,   xMax: 3.5,  zMin: -6,     zMax: 9 },      // right branch (approx)
    { xMin: -3.5,  xMax: 3.5,  zMin: -7.5,   zMax: -6 },     // ending horizontal (slightly extended)
    { xMin: -1.0,  xMax: 1.0,  zMin: -15,    zMax: -10 }     // final vertical approach
  ];

  function isInPaddedPath(x, z, padding) {
    for(let p of rawPathBounds) {
      const xmin = p.xMin - padding;
      const xmax = p.xMax + padding;
      const zmin = p.zMin - padding;
      const zmax = p.zMax + padding;
      if(x >= xmin && x <= xmax && z >= zmin && z <= zmax) return true;
    }
    return false;
  }

  // spawn trees
  let tries = 0;
  let spawned = 0;
  while(spawned < TREE_COUNT && tries < TREE_COUNT * 20) {
    tries++;
    const x = (Math.random() - 0.5) * 50;
    const z = (Math.random() - 0.5) * 50;

    // skip if too close to any path (padding)
    if(isInPaddedPath(x, z, TREE_PADDING)) continue;

    const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
    // base small scale for all
    let scale = 0.12 + Math.random() * 0.08; // ~0.12 -> 0.20
    if(type === 'tree4') scale *= 1.6; // tree4 slightly larger by default (multiplier)

    // lift a bit so models don't clip into ground depending on origin
    const y = 0.2 + (scale * 0.2);

    const rotY = Math.random() * 360;
    const tree = document.createElement('a-entity');
    tree.setAttribute('gltf-model', `#${type}`);
    tree.setAttribute('position', `${x} ${y} ${z}`);
    tree.setAttribute('scale', `${scale} ${scale} ${scale}`);
    tree.setAttribute('rotation', `0 ${rotY} 0`);
    treesEl.appendChild(tree);

    spawned++;
  }

  // if too few spawned, log in console (helps debugging)
  if(spawned < TREE_COUNT) {
    console.warn(`spawned ${spawned} trees (requested ${TREE_COUNT}) â€” increase attempts or reduce padding/paths`);
  }
})();
</script>

</a-scene>
</body>
</html>

