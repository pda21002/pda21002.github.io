<html>
<head>
  <meta charset="utf-8" />
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
<a-scene cursor="rayOrigin: mouse" raycaster="objects: .fork-menu-button" keyboard-shortcuts="">

  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">
    <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
    <a-asset-item id="goblin" src="assets/goblin_mob.glb"></a-asset-item>
  </a-assets>

  <!-- Ground -->
  <a-plane rotation="-90 0 0" width="50" height="50"
           material="repeat: 20 20; shader: flat; src: #groundTexture"></a-plane>

  <!-- Paths (unchanged) -->
  <a-box width="1.5" height="0.05" depth="8" position="0 0.025 12.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03943 8.75"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box class="left-branch" width="1.5" height="0.05" depth="14" position="-2.76655 0.025 1.00951"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="middle-branch" width="1.5" height="0.05" depth="14" position="0 0.025 1.03888"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="right-branch" width="1.5" height="0.05" depth="14" position="2.737 0.025 1.01381"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03169 -6.25"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box width="1.5" height="0.05" depth="8" position="0 0.025 -10.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu -->
  <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left" position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle" width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right" position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-box id="castle" position="0 0.5 -15" width="2" height="2" depth="2" color="gold"></a-box>

  <!-- Player rig -->
  <a-entity id="rig" position="0 0.5 16" player-movement>
    <a-entity camera look-controls></a-entity>
  </a-entity>

  <!-- Tree holder -->
  <a-entity id="trees"></a-entity>

  <!-- Goblin placed near end of right path and slightly left -->
  <a-entity id="goblinEntity" gltf-model="#goblin" position="2.5 0 -4" scale="0.3 0.3 0.3"
            goblin-behavior="walkIndex:1; lookDistance:3; startWalkDistance:1.6; speed:1.2">
  </a-entity>

<script>
/* -----------------------
   Player movement component
   - arrow keys (camera-relative)
   - enforces section-based bounds
   - when followingGoblin true, frees player to roam
   ----------------------- */
AFRAME.registerComponent('player-movement', {
  init: function () {
    this.choiceMade = false;
    this.chosenPath = null;
    this.followingGoblin = false; // toggled when goblin starts walking
    this.keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
    const scene = this.el.sceneEl;

    window.addEventListener('keydown', e => { if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = true; });
    window.addEventListener('keyup', e => { if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = false; });

    // Fork menu clicks
    scene.querySelectorAll('.fork-menu-button').forEach(btn=>{
      btn.addEventListener('click', () => {
        this.chosenPath = btn.getAttribute('data-choice');
        this.choiceMade = true;
        document.getElementById('forkMenu').setAttribute('visible', false);

        // Prevent the buttons from being targeted by the cursor after click (fixes freeze)
        scene.querySelectorAll('.fork-menu-button').forEach(b => b.classList.remove('fork-menu-button'));
        // Also remove raycast objects list just in case
        const cursorEl = scene.querySelector('[cursor]');
        if(cursorEl && cursorEl.components && cursorEl.components.raycaster) {
          cursorEl.components.raycaster.data.objects = '';
        }

        // allow following goblin *only* when player chooses the right path initially?
        // We'll let goblin decide (goblin will set followingGoblin when it starts walking).
      });
      btn.setAttribute('material','depthTest:false;');
      btn.object3D.renderOrder = 999;
    });
  },

  tick: function () {
    const rig = this.el;
    let pos = rig.getAttribute('position');
    const speed = 0.025;

    // stop at fork until choice made
    if (!this.choiceMade && pos.z <= 8.75) {
      pos.z = 8.75;
      rig.setAttribute('position', pos);
      document.getElementById('forkMenu').setAttribute('visible', true);
      return;
    }

    // camera-relative movement
    const camera = this.el.sceneEl.camera.el.object3D;
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0; camDir.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();

    let dx = 0, dz = 0;
    if (this.keys.ArrowUp) { dx -= camDir.x * speed; dz -= camDir.z * speed; }
    if (this.keys.ArrowDown) { dx += camDir.x * speed; dz += camDir.z * speed; }
    if (this.keys.ArrowLeft) { dx -= right.x * speed; dz -= right.z * speed; }
    if (this.keys.ArrowRight) { dx += right.x * speed; dz += right.z * speed; }

    pos.x += dx; pos.z += dz;

    // bounds logic:
    // - before choice: corridor bounds
    // - branch section: only chosen path accessible (tighter/slimmer)
    // - after branch and if goblin started walking and told us, free roam into forest on chosen side
    let bounds;
    if (!this.choiceMade) {
      bounds = { xMin:-0.75, xMax:0.75, zMin:-15, zMax:16.75 };
    } else if (pos.z <= 8.75 && pos.z > -6) {
      if (this.chosenPath === 'left')  bounds = { xMin:-3.3, xMax:-2.3, zMin:-6.25, zMax:8.75 };
      if (this.chosenPath === 'middle') bounds = { xMin:-0.75, xMax:0.75, zMin:-6.25, zMax:8.75 };
      if (this.chosenPath === 'right' && !this.followingGoblin) bounds = { xMin:2.2, xMax:3.2, zMin:-6.25, zMax:8.75 };
      else if (this.chosenPath === 'right' && this.followingGoblin) bounds = { xMin:-25, xMax:25, zMin:-25, zMax:25 };
      else bounds = { xMin:-25, xMax:25, zMin:-25, zMax:25 }; // fallback
    } else {
      // After the branches: horizontal sections should be fully accessible
      bounds = { xMin:-25, xMax:25, zMin:-25, zMax:25 };
    }

    pos.x = Math.max(bounds.xMin, Math.min(bounds.xMax, pos.x));
    pos.z = Math.max(bounds.zMin, Math.min(bounds.zMax, pos.z));
    rig.setAttribute('position', pos);
  }
});


/* -----------------------
   Goblin behavior component
   - uses Three AnimationMixer on the loaded glTF model
   - plays animation by index (walkIndex)
   - initial orientation: face +X (right / forest)
   - when player is within lookDistance: look at player once
   - when player within startWalkDistance: face +X, start walk animation and walking movement,
     and notify player component to allow following into forest
   ----------------------- */
AFRAME.registerComponent('goblin-behavior', {
  schema: {
    walkIndex: { type: 'int', default: 1 },       // pick correct animation index (0,1,2)
    lookDistance: { type: 'number', default: 3.0 },
    startWalkDistance: { type: 'number', default: 1.6 },
    speed: { type: 'number', default: 1.2 }       // units per second
  },

  init: function () {
    this.state = 'idle';
    this.mixer = null;
    this.walkAction = null;
    this.animations = [];
    this.modelRoot = null;
    this.hasLooked = false;
    this.walkingStarted = false;
    this.rig = document.getElementById('rig');

    // ensure initial facing is +X (right)
    if (this.el.object3D) {
      this.el.object3D.rotation.set(0, THREE.MathUtils.degToRad(90), 0);
    }

    // cache animations when model loads
    this.el.addEventListener('model-loaded', (e) => {
      const gltfScene = e.detail && e.detail.model;
      const mesh = this.el.getObject3D('mesh') || gltfScene;
      this.modelRoot = mesh || null;

      // prefer animations on the glTF scene or mesh
      this.animations = (gltfScene && gltfScene.animations && gltfScene.animations.slice()) ||
                        (mesh && mesh.animations && mesh.animations.slice()) || [];

      console.log('[goblin] model loaded, animations =', this.animations.length,
                  'names =', this.animations.map(a => a.name || '<unnamed>'));
    });
  },

  tick: function (time, timeDelta) {
    if (!this.rig || !this.el.object3D) return;
    const gob3 = this.el.object3D;
    const rig3 = this.rig.object3D;
    const dx = rig3.position.x - gob3.position.x;
    const dz = rig3.position.z - gob3.position.z;
    const dist = Math.hypot(dx, dz);
    const dt = (timeDelta || 0) / 1000;

    // advance mixer if created
    if (this.mixer) {
      try { this.mixer.update(dt); } catch (err) { /* ignore */ }
    }

    // 1) look at player once when in range
    if (this.state === 'idle' && dist <= this.data.lookDistance && !this.hasLooked) {
      // compute yaw angle to face player and apply only horizontal rotation
      const angleToPlayer = Math.atan2(rig3.position.x - gob3.position.x, rig3.position.z - gob3.position.z);
      gob3.rotation.set(0, angleToPlayer, 0);
      this.hasLooked = true;
      // short-circuit here so look happens but movement doesn't start until startWalkDistance
    }

    // 2) start walking once when player very close
    if (this.state === 'idle' && dist <= this.data.startWalkDistance && !this.walkingStarted) {
      // face +X (forest) before walking
      gob3.rotation.set(0, THREE.MathUtils.degToRad(90), 0);

      // try to create an AnimationMixer and play named clip by index
      if (this.modelRoot && this.animations && this.animations.length > this.data.walkIndex) {
        try {
          this.mixer = new THREE.AnimationMixer(this.modelRoot);
          const clip = this.animations[this.data.walkIndex];
          this.walkAction = this.mixer.clipAction(clip);
          this.walkAction.setLoop(THREE.LoopRepeat);
          this.walkAction.play();
          console.log('[goblin] walk animation started at index', this.data.walkIndex);
        } catch (err) {
          console.warn('[goblin] mixer/clip play error', err);
          this.mixer = null;
          this.walkAction = null;
        }
      } else {
        // no animations found or index out of range — we'll still move visually
        console.log('[goblin] no walk clip found (index out of range?) — will move without animation');
      }

      this.walkingStarted = true;
      this.state = 'walking';

      // Notify player movement to allow following into forest (break their branch restriction)
      const playerComp = this.rig.components && this.rig.components['player-movement'];
      if (playerComp) {
        playerComp.followingGoblin = true;
        console.log('[goblin] told player to allow following into forest');
      }
    }

    // 3) walking motion
    if (this.state === 'walking') {
      // avoid goblin overlapping the player — maintain a tiny separation
      const minSeparation = 0.6;
      if (dist > minSeparation) {
        // Move in world +X direction (forest is to the right)
        gob3.position.x += this.data.speed * dt; // world-space +X movement
        // sync A-Frame attribute so getAttribute sees new values
        this.el.setAttribute('position', `${gob3.position.x} ${gob3.position.y} ${gob3.position.z}`);
      }
    }
  }
});


/* -----------------------
   Trees scattering
   - avoids path areas (inPath)
   - uses tree4 everywhere except in the narrow "between branches" density area
   ----------------------- */
(function scatterTrees() {
  const trees = document.getElementById('trees');
  if (!trees) return;
  const treeTypes = ['tree1','tree2','tree3','tree4'];
  const branchTreeTypes = ['tree1','tree2','tree3'];

  function inPath(x,z){
    // Corridor (intro vertical)
    if (x > -0.9 && x < 0.9 && z > 8.75 && z < 16.75) return true;
    // First horizontal
    if (x > -3.5 && x < 3.5 && z > 8 && z < 9.5) return true;
    // Left branch
    if (x > -3.3 && x < -2.3 && z > -6.25 && z < 8.75) return true;
    // Middle branch
    if (x > -0.75 && x < 0.75 && z > -6.25 && z < 8.75) return true;
    // Right branch
    if (x > 2.3 && x < 3.3 && z > -6.25 && z < 8.75) return true;
    // Second horizontal
    if (x > -3.5 && x < 3.5 && z > -7.5 && z < -6) return true;
    // Castle approach
    if (x > -0.9 && x < 0.9 && z < -6.25 && z > -15) return true;
    return false;
  }

  // general trees (scattered)
  for (let i=0; i<380; i++){
    const x = (Math.random()-0.5)*50;
    const z = (Math.random()-0.5)*50;
    if (inPath(x,z)) continue;
    const type = treeTypes[Math.floor(Math.random()*treeTypes.length)];
    let scale = 0.01 + Math.random()*0.01;
    if (type === 'tree4') scale *= 20; // keep tree4 large but not massive
    if (type === 'tree3') scale *= 4;
    const rotY = Math.random()*360;
    const ent = document.createElement('a-entity');
    ent.setAttribute('gltf-model', `#${type}`);
    ent.setAttribute('position', `${x} 0 ${z}`);
    ent.setAttribute('scale', `${scale} ${scale} ${scale}`);
    ent.setAttribute('rotation', `0 ${rotY} 0`);
    trees.appendChild(ent);
  }

  // dense trees between branches (two gaps: left-middle, middle-right)
  for (let i=0; i<150; i++){
    const z = -6 + Math.random()*14; // along branch length
    let x;
    if (Math.random() < 0.5) {
      // between left and middle (center around -2.0)
      x = -2.0 + (Math.random() * 1.0); // [-2.0, -1.0]
    } else {
      // between middle and right (center around 1.0)
      x = 1.0 + (Math.random() * 1.0);  // [1.0, 2.0]
    }
    const type = branchTreeTypes[Math.floor(Math.random()*branchTreeTypes.length)]; // no tree4 here
    let scale = 0.01 + Math.random()*0.01;
    if (type === 'tree3') scale *= 4;
    const rotY = Math.random()*360;
    const ent = document.createElement('a-entity');
    ent.setAttribute('gltf-model', `#${type}`);
    ent.setAttribute('position', `${x} 0 ${z}`);
    ent.setAttribute('scale', `${scale} ${scale} ${scale}`);
    ent.setAttribute('rotation', `0 ${rotY} 0`);
    trees.appendChild(ent);
  }
})();

</script>
</a-scene>
</body>
</html>
