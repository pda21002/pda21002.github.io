<html>
<head>
  <meta charset="utf-8" />
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
<a-scene cursor="rayOrigin: mouse"
         raycaster="objects: .clickable, .fork-menu-button, .ghost-choice">



  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">
    <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
    <a-asset-item id="goblin" src="assets/goblin_mob.glb"></a-asset-item>
    <a-asset-item id="fairy1" src="assets/fairy_gm_villager1.glb"></a-asset-item>
    <a-asset-item id="fairy2" src="assets/fairy_gm_villager3.glb"></a-asset-item>
    <a-asset-item id="fairy3" src="assets/fairy_gm_villager4.glb"></a-asset-item>
    <a-asset-item id="fairy4" src="assets/fairy_gm_villager5.glb"></a-asset-item>
    <a-asset-item id="fairy5" src="assets/fairy_gm_villager6.glb"></a-asset-item>
    <a-asset-item id="house" src="assets/big_medieval_town_house_4.glb"></a-asset-item>
    <a-asset-item id="castle" src="assets/pixel_artvoxel_art_castle.glb"></a-asset-item>
    <a-asset-item id="witch" src="assets/little_witch.glb"></a-asset-item>
    <a-asset-item id="mushroom" src="assets/mushroom_bup_minecraft_mob.glb"></a-asset-item>
     <a-asset-item id="creepygirl" src="assets/creepy_girl.glb"></a-asset-item>
      <a-asset-item id="sisters" src="assets/sisters.glb"></a-asset-item>
      <a-asset-item id="dwarf" src="assets/swaying_dwarf.glb"></a-asset-item>
      <a-asset-item id="wizard" src="assets/the_green_wizard_gnome_n64_style.glb"></a-asset-item>
      <a-asset-item id="fox" src="assets/voxel_fox.glb"></a-asset-item>
      <a-asset-item id="butterflies" src="assets/the_butterflies.glb"></a-asset-item>
          <a-asset-item id="ghost" src="assets/nightmare_creature_3.glb"></a-asset-item>
  </a-assets>

  <!-- Ground -->
  <a-plane rotation="-90 0 0" width="80" height="80"
           material="repeat: 30 30; shader: flat; src: #groundTexture"></a-plane>

  <!-- Paths -->
  <a-box width="1.5" height="0.05" depth="20" position="0 0.025 19.46702" 
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03943 8.75"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box class="left-branch" width="1.5" height="0.05" depth="14" position="-2.76655 0.025 1.00951"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="middle-branch" width="1.5" height="0.05" depth="14" position="0 0.025 1.03888"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box class="right-branch" width="1.5" height="0.05" depth="14" position="2.737 0.025 1.01381"
         material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box width="7" height="0.05" depth="1.5" position="0 0.03169 -6.25"
         material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>
  <a-box width="1.5" height="0.05" depth="8" position="0 0.025 -10.75"
         material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu -->
 <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left" position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle" width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right" position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-entity gltf-model="#castle" position="6.99881 -0.8 -76.225" width="2"></a-entity>

  <!-- Player rig -->
  <a-entity id="rig" position="0 0.5 16" player-movement>
    <a-entity camera look-controls></a-entity>
  </a-entity>

  <!-- House -->
  <a-entity gltf-model="#house" position="-0.16089 0 30.2737" scale="0.15 0.18 0.15" rotation="0 180 0"></a-entity>

  <!-- Tree holder -->
  <a-entity id="trees"></a-entity>

  <!-- Fairies -->
  <a-entity id="fairies">
    <a-entity gltf-model="#fairy1" position="3.74164 0.77241 7.10959" scale="0.08 0.08 0.08" rotation="0 155 0" fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2"></a-entity>
    <a-entity gltf-model="#fairy2" position="3.7658 0.95 7.2" scale="0.08 0.08 0.08" rotation="-10.94 140.27 0" fairy-behavior="idleAnim:idle; reactAnim:interact2; reactDistance:2"></a-entity>
    <a-entity gltf-model="#fairy3" position="3.6441 0.85 7.09739" scale="0.08 0.08 0.08" rotation="0 150 0" fairy-behavior="idleAnim:idle; reactAnim:cantar; reactDistance:2"></a-entity>
    <a-entity gltf-model="#fairy4" position="3.82107 0.81339 7.2185" scale="0.08 0.08 0.08" rotation="0 132 0" fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2"></a-entity>
    <a-entity gltf-model="#fairy5" position="3.65 1 7.15" scale="0.08 0.08 0.08" rotation="-14.46 150 0" fairy-behavior="idleAnim:idle; reactAnim:interact1; reactDistance:2"></a-entity>
  </a-entity>

  
  <!-- Witch -->
  
<a-entity id="witchWrapper" position="2.35 0.04454 4.80785" rotation="0 -14.72 0">
  <a-entity gltf-model="#witch"
            scale="0.25 0.25 0.25"
            rotation="0 -135 0"
            witch-behavior="reactAnim: bye; reactDistance: 2">
  </a-entity>

  <!-- Shadow + main text grouped -->
  <a-entity id="witchTextWrapper" visible="false">
    <a-text value="Hello! If you're looking for the palace, you're on the right path. Just don't get distracted!"
            position="0.15816 0.44674 0.11927"
            align="center"
            color="#000"
            side="double"
            scale="0.15 0.15 0.15"
            rotation="0 40 0">
    </a-text>

    <a-text value="Hello! If you're looking for the palace, you're on the right path. Just don't get distracted!"
            position="0.15725 0.44674 0.12232"
            align="center"
            color="#fff"
            side="double"
            scale="0.15 0.15 0.15"
            rotation="0 40 0">
    </a-text>
  </a-entity>
</a-entity>

  <a-entity id="wizardWrapper" position="-0.02192 0.04843 -1.66883">
  <a-entity gltf-model="#wizard" scale="0.4 0.4 0.4"
            wizard-interact="range: 1.5; textId: wizardText"></a-entity>
    
  <!-- Shadow text -->
<a-text value="WHERE DO YOU THINK YOU'RE GOING?!" position="0.00345 0.45824 0.00929" color="#000" align="center" side="double" scale="0.25 0.25 0.25" visible="false" id="wizardTextShadow"></a-text>

  <!-- Foreground text -->
<a-text value="WHERE DO YOU THINK YOU'RE GOING?!" position="0 0.46284 0.01" color="#fff" align="center" side="double" scale="0.25 0.25 0.25" visible="false" id="wizardText"></a-text>
  
</a-entity>

<a-entity id="wizardChoices" visible="false" position="0 0.35 -1.71145" scale="0.44 0.43 0.23">
  <a-box class="wizard-choice clickable" data-choice="ignore" color="red" width="1" height="0.5" depth="0.2" position="-1 1 0" text="align: center; color: white; value: Ignore; width: 4">
  </a-box>

  <a-box class="wizard-choice clickable" data-choice="explain" color="green" width="1" height="0.5" depth="0.2" position="0 1 0" text="align: center; color: white; value: Explain; width: 4">
  </a-box>

  <a-box class="wizard-choice clickable" data-choice="getOut" color="blue" width="1" height="0.5" depth="0.2" position="1 1 0" text="align: center; color: white; value: Get Out; width: 4">
  </a-box>
</a-entity>

  

  <!-- Mushroom -->
  <a-entity gltf-model="#mushroom" position="3.335 0.05 0" rotation="0 150 0" scale="0.15 0.15 0.15" mushroom-behavior="idleAnim:idle"></a-entity>

  <!-- Goblin -->
  <a-entity gltf-model="#goblin" position="2.5 0 -4" scale="0.3 0.3 0.3" goblin-behavior="walkIndex:0; lookDistance:4; startWalkDistance:1.6; speed:1.2"></a-entity>

<a-entity gltf-model="#creepygirl" position="-3.20252 0.04765 5.73719" scale="0.0007 0.0007 0.0007" rotation="0 25 0"></a-entity>
  <a-entity gltf-model="#sisters" position="-2.60894 0.58665 1.29681" scale="0.08 0.08 0.08" rotation="0 -110 0"></a-entity>
  <a-entity gltf-model="#dwarf" position="-0.29412 0.05046 4.64215" scale="0.008 0.008 0.008" rotation="0 20 0"></a-entity>
  <a-entity gltf-model="#fox" position="0.33427 0.05 7.18987" scale="0.045 0.045 0.045" rotation="0 70 0" fox-behavior="idleAnim:Sleeping"></a-entity>
  <a-entity gltf-model="#butterflies" position="-0.16089 0 30.2737" scale="1 1 1" rotation="0 0 0"></a-entity>
  <a-entity gltf-model="#ghost" position="-2.8142 0.08774 -3.2995" scale="0.2 0.2 0.2" ghost-behavior></a-entity>

 <a-entity id="ghostChoices" visible="false" position="-2.8142 1.04864 -3.21153" scale="0.24 0.19 0.3">
    <a-box class="ghost-choice" data-choice="kill" color="red" width="1" height="0.5" depth="0.2" position="-1 0 0" text="align: center; color: white; value: Kill Him; width: 4">
    </a-box>
    <a-box class="ghost-choice" data-choice="ignore" color="blue" width="1" height="0.5" depth="0.2" position="1 0 0" text="align: center; color: white; value: Ignore Him; width: 4">
    </a-box>
  </a-entity>
  
<script>
/* -----------------------
   Player movement
----------------------- */
AFRAME.registerComponent('player-movement', {
  init: function () {
    this.pause = false; 
    this.choiceMade = false;
    this.chosenPath = null;
    this.followingGoblin = false;
    this.keys = {ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false};
    const scene = this.el.sceneEl;

    // Key handling
    window.addEventListener('keydown', e => { if(this.keys.hasOwnProperty(e.key)) this.keys[e.key]=true; });
    window.addEventListener('keyup', e => { if(this.keys.hasOwnProperty(e.key)) this.keys[e.key]=false; });

    // Fork menu buttons
    scene.querySelectorAll('.fork-menu-button').forEach(btn => {
      btn.addEventListener('click', () => {
        this.chosenPath = btn.getAttribute('data-choice');
        this.choiceMade = true;
        document.getElementById('forkMenu').setAttribute('visible', false);

        // remove button class so raycaster stops detecting them
        scene.querySelectorAll('.fork-menu-button').forEach(b => b.classList.remove('fork-menu-button'));
        const cursorEl = scene.querySelector('[cursor]');
        if(cursorEl && cursorEl.components && cursorEl.components.raycaster)
          cursorEl.components.raycaster.data.objects = '';
      });
      btn.setAttribute('material','depthTest:false;');
      btn.object3D.renderOrder = 999;
    });
  },

tick: function () {
   if (this.pause) return;
  
  const rig = this.el;
  let pos = rig.getAttribute('position');
  const speed = 0.025;

  // --- Camera-relative movement ---
  const camera = this.el.sceneEl.camera.el.object3D;
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);
  camDir.y = 0; camDir.normalize();
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();
  let dx=0, dz=0;
  if(this.keys.ArrowUp){ dx -= camDir.x*speed; dz -= camDir.z*speed; }
  if(this.keys.ArrowDown){ dx += camDir.x*speed; dz += camDir.z*speed; }
  if(this.keys.ArrowLeft){ dx -= right.x*speed; dz -= right.z*speed; }
  if(this.keys.ArrowRight){ dx += right.x*speed; dz += right.z*speed; }
  pos.x += dx; pos.z += dz;

  // --- Fork menu enforcement ---
const forkZ = 9.5;
if (!this.choiceMade && pos.z <= forkZ) {
  // Lock player exactly at the fork position
  rig.setAttribute('position', {x: 0, y: pos.y, z: forkZ});
  
  // Show menu
  document.getElementById('forkMenu').setAttribute('visible', true);

  // ❌ Skip movement updates
  return;
}

  // --- Movement bounds ---
  let bounds;

  if (!this.choiceMade) {
    // Player is still on the first path before choice
    bounds = {xMin:-0.75, xMax:0.75, zMin:9.5, zMax:29}; 
  } else {
    // After choice → branch paths
    if (pos.z <= 8.75 && pos.z > -6) {
      if (this.chosenPath === 'left') 
        bounds = {xMin:-3.3,xMax:-2.3,zMin:-6.25,zMax:8.75};
      else if (this.chosenPath === 'middle') 
        bounds = {xMin:-0.75,xMax:0.75,zMin:-6.25,zMax:8.75};
      else if (this.chosenPath === 'right' && !this.followingGoblin) 
        bounds = {xMin:2.2,xMax:3.2,zMin:-6.25,zMax:8.75};
      else 
        bounds = {xMin:-25,xMax:25,zMin:-25,zMax:25};
    } else {
      // Free roaming after fork
      bounds = {xMin:-25,xMax:25,zMin:-25,zMax:25};
    }
  }

  // Apply boundaries
  pos.x = Math.max(bounds.xMin, Math.min(bounds.xMax, pos.x));
  pos.z = Math.max(bounds.zMin, Math.min(bounds.zMax, pos.z));
  rig.setAttribute('position', pos);

  // --- Losing condition ---
  const origin = new THREE.Vector3(0,0,16);
  const playerPos = new THREE.Vector3(pos.x,pos.y,pos.z);
  if(playerPos.distanceTo(origin) > 35){
    alert('You wandered too far and got lost! Game over.');
    window.location.reload();
  }
  }
}); 


/* -----------------------
   Goblin behavior
----------------------- */
AFRAME.registerComponent('goblin-behavior', {
  schema: {
    walkIndex: { type: 'int', default: 0 },
    lookDistance: { type: 'number', default: 6 },
    startWalkDistance: { type: 'number', default: 1.6 },
    speed: { type: 'number', default: 1.2 }
  },

  init: function() {
    this.state = 'idle';
    this.mixer = null;
    this.walkAction = null;
    this.animations = [];
    this.modelRoot = null;
    this.hasLooked = false;
    this.walkingStarted = false;
    this.rig = document.getElementById('rig');

    // Start goblin at y=2.5 (on path)
    const pos = this.el.getAttribute('position');
    this.el.setAttribute('position', { x: pos.x, y: 0.05, z: pos.z });

    this.el.addEventListener('model-loaded', (e) => {
      const gltfScene = e.detail.model;
      this.modelRoot = this.el.getObject3D('mesh') || gltfScene;
      this.animations = (gltfScene?.animations?.slice()) || [];

      if (this.modelRoot) {
        // Rotate model so front faces +X
        this.modelRoot.rotation.y = THREE.MathUtils.degToRad(-90);
      }
      this.el.object3D.rotation.set(0, 0, 0); // parent aligned with world axes
    });
  },

  tick: function(time, timeDelta) {
    if (!this.rig || !this.el.object3D) return;
    const gob3 = this.el.object3D;
    const rig3 = this.rig.object3D;
    const dx = rig3.position.x - gob3.position.x;
    const dz = rig3.position.z - gob3.position.z;
    const dist = Math.hypot(dx, dz);
    const dt = (timeDelta || 0) / 1000;

    if (this.mixer) try { this.mixer.update(dt); } catch (err) {}

    // 1) Look at player once when approaching
    if (this.state === 'idle' && dist <= this.data.lookDistance && !this.hasLooked) {
      const angleToPlayer = Math.atan2(
        rig3.position.x - gob3.position.x,
        rig3.position.z - gob3.position.z
      );
      gob3.rotation.y = angleToPlayer - THREE.MathUtils.degToRad(90);
      this.hasLooked = true;
    }

    // 2) Start walking when player very close
    if (this.state === 'idle' && dist <= this.data.startWalkDistance && !this.walkingStarted) {
      gob3.rotation.y = 0; // face +X again

      if (this.modelRoot && this.animations.length > this.data.walkIndex) {
        try {
          this.mixer = new THREE.AnimationMixer(this.modelRoot);
          this.walkAction = this.mixer.clipAction(this.animations[this.data.walkIndex]);
          this.walkAction.setLoop(THREE.LoopRepeat);
          this.walkAction.play();
        } catch (err) {
          console.warn(err);
          this.mixer = null;
          this.walkAction = null;
        }
      }

      this.walkingStarted = true;
      this.state = 'walking';

      const playerComp = this.rig.components['player-movement'];
      if (playerComp) playerComp.followingGoblin = true;
    }

    // 3) Walking motion
    if (this.state === 'walking') {
      const minSeparation = 0.6;
      if (dist > minSeparation) {
        gob3.position.x += this.data.speed * dt; // move right

        // Abrupt "step off" when past end of path
        if (gob3.position.x > 3.525 && gob3.position.y > 0) {
          gob3.position.y = 0;
        }

        this.el.setAttribute('position', {
          x: gob3.position.x,
          y: gob3.position.y,
          z: gob3.position.z
        });
      }
    }
  }
});

  
AFRAME.registerComponent('witch-behavior', {
  schema: {
    reactAnim: { type: 'string', default: 'bye' },
    reactDistance: { type: 'number', default: 2 }
  },

  init: function() {
    this.player = document.querySelector('#rig');
    this.mixer = null;
    this.actions = {};
this.textEl = this.el.parentNode.querySelector('#witchTextWrapper');
    this.hasPlayed = false;

    this.el.addEventListener('model-loaded', (e) => {
      const model = e.detail.model;
      if (!model) return;

      this.mixer = new THREE.AnimationMixer(model);

      const animations = model.animations || [];
      animations.forEach(clip => {
        const action = this.mixer.clipAction(clip);
        if (clip.name === this.data.reactAnim) {
          action.setLoop(THREE.LoopOnce);
          action.clampWhenFinished = true;
        }
        this.actions[clip.name] = action;
      });
    });
  },

  tick: function(time, deltaTime) {
    if (!this.player || !this.mixer || !this.actions[this.data.reactAnim]) return;

    const playerPos = new THREE.Vector3();
    const witchPos = new THREE.Vector3();
    this.player.object3D.getWorldPosition(playerPos);
    this.el.object3D.getWorldPosition(witchPos);

    const distance = playerPos.distanceTo(witchPos);

    if (distance < this.data.reactDistance) {
      if (!this.hasPlayed) {
        // Play animation once
        this.actions[this.data.reactAnim].reset().play();
        this.hasPlayed = true;

        // Show text
        if (this.textEl) this.textEl.setAttribute('visible', true);

        // Hide text after 3 seconds
        setTimeout(() => {
          if (this.textEl) this.textEl.setAttribute('visible', false);
        }, 10000);
      }
    } else {
      // Reset so it can play next time player re-approaches
      this.hasPlayed = false;
    }

    this.mixer.update(deltaTime / 1000);
  }
});



  
  AFRAME.registerComponent('fairy-behavior', {
  schema: {
    idleAnim: {type:'string', default:'Idle'},
    reactAnim: {type:'string', default:'React'},
    reactDistance: {type:'number', default:2},
    speed: {type:'number', default:0} // optional if you want flying motion
  },
  init:function(){
    this.rig=document.getElementById('rig');
    this.modelRoot=null; this.mixer=null;
    this.currentAction=null; this.idleAction=null; this.reactAction=null;

    this.el.addEventListener('model-loaded', (e)=>{
      const gltf=e.detail.model;
      this.modelRoot=this.el.getObject3D('mesh')||gltf;
      if(!this.modelRoot) return;
      const clips=gltf.animations||[];
      this.idleAction=null; this.reactAction=null;
      clips.forEach(c=>{
        if(c.name===this.data.idleAnim) this.idleAction=c;
        if(c.name===this.data.reactAnim) this.reactAction=c;
      });
      if(this.idleAction){
        this.mixer=new THREE.AnimationMixer(this.modelRoot);
        const act=this.mixer.clipAction(this.idleAction);
        act.play();
        this.currentAction='idle';
      }
    });
  },
  tick:function(time,timeDelta){
    if(!this.rig||!this.modelRoot||!this.mixer) return;
    const pos=this.el.object3D.position;
    const rigPos=this.rig.object3D.position;
    const dist=Math.hypot(pos.x-rigPos.x,pos.z-rigPos.z);
    const dt=(timeDelta||0)/1000;

    // decide which animation
    if(dist<=this.data.reactDistance && this.reactAction && this.currentAction!=='react'){
      this.mixer.stopAllAction();
      const act=this.mixer.clipAction(this.reactAction);
      act.setLoop(THREE.LoopOnce); act.clampWhenFinished=true; act.play();
      this.currentAction='react';
    } else if(dist>this.data.reactDistance && this.idleAction && this.currentAction!=='idle'){
      this.mixer.stopAllAction();
      const act=this.mixer.clipAction(this.idleAction);
      act.setLoop(THREE.LoopRepeat); act.play();
      this.currentAction='idle';
    }

    this.mixer.update(dt);
  }
});
  

AFRAME.registerComponent('mushroom-behavior', {
  schema: {
    idleAnim: {type: 'string', default: 'idle'}
  },
  init: function () {
    this.mixer = null;
    this.idleAction = null;
    this.el.addEventListener('model-loaded', e => {
      const model = e.detail.model;
      if (!model) return;
      this.mixer = new THREE.AnimationMixer(model);
      const clips = model.animations || [];
      const idle = clips.find(c => c.name === this.data.idleAnim);
      if (idle) {
        this.idleAction = this.mixer.clipAction(idle);
        this.idleAction.setLoop(THREE.LoopRepeat);
        this.idleAction.play();
      }
    });
  },
  tick: function (time, dt) {
    if (this.mixer) this.mixer.update(dt/1000);
  }
});


AFRAME.registerComponent('fox-behavior', {
  schema: {
    idleAnim: {type: 'string', default: 'Sleeping'}
  },
  init: function () {
    this.mixer = null;
    this.idleAction = null;
    this.el.addEventListener('model-loaded', e => {
      const model = e.detail.model;
      if (!model) return;
      this.mixer = new THREE.AnimationMixer(model);
      const clips = model.animations || [];
      const idle = clips.find(c => c.name === this.data.idleAnim);
      if (idle) {
        this.idleAction = this.mixer.clipAction(idle);
        this.idleAction.setLoop(THREE.LoopRepeat);
        this.idleAction.play();
      }
    });
  },
  tick: function (time, dt) {
    if (this.mixer) this.mixer.update(dt/1000);
  }
});
  
  
AFRAME.registerComponent('wizard-interact', {
  schema: {
    idleAnim:        { type: 'string', default: 'Wizard_Gnome_Armature|idle' },
    approachAnim:    { type: 'string', default: 'Wizard_Gnome_Armature|Fall' },
    explainAnim:     { type: 'string', default: 'Wizard_Gnome_Armature|agree' },
    ignoreStartAnim: { type: 'string', default: 'Wizard_Gnome_Armature|disagree' },
    ignoreDeathAnim: { type: 'string', default: 'Wizard_Gnome_Armature|Hit' },
    getOutStartAnim: { type: 'string', default: 'Wizard_Gnome_Armature|Curse' },
    reactDistance:   { type: 'number', default: 2 },
    approachStep:    { type: 'number', default: 0.5 },
    choiceDelay:     { type: 'number', default: 700 } //
  },

  init: function() {
    this.player = document.querySelector('#rig');
    this.textEl = document.querySelector('#wizardText');
    this.shadowEl = document.querySelector('#wizardTextShadow');
    this.choices = document.querySelector('#wizardChoices');
    this.buttons = Array.from(this.choices.querySelectorAll('.wizard-choice'));
    this.mixer = null;
    this.actions = {};
    this.interacted = false;
    this.sequenceQueue = [];

    this.el.addEventListener('model-loaded', e => {
      const model = e.detail.model;
      if (!model) return;

      this.mixer = new THREE.AnimationMixer(model);
      (model.animations || []).forEach(clip => {
        const action = this.mixer.clipAction(clip);
        action.clampWhenFinished = true;
        this.actions[clip.name] = action;
      });

      // Start idle loop
      this.playLoop(this.data.idleAnim);
    });

    // Hook up choice clicks
    this.buttons.forEach(btn => {
      btn.addEventListener('click', () => 
        this.handleChoice(btn.getAttribute('data-choice'))
      );
    });
  },

  tick: function(time, delta) {
    if (this.mixer) this.mixer.update(delta / 1000);

    if (!this.interacted) {
      const playerPos = new THREE.Vector3();
      const wizardPos = new THREE.Vector3();
      this.player.object3D.getWorldPosition(playerPos);
      this.el.object3D.getWorldPosition(wizardPos);

      if (playerPos.distanceTo(wizardPos) < this.data.reactDistance) {
        this.interacted = true;
        this.startReaction();
      }
    }

    // Handle movement ONLY along X axis
    if (this.currentStep && this.currentStep.moveTowardPlayer) {
      const wizardPos = this.el.object3D.position.clone();
      const playerPos = this.player.object3D.position.clone();

      // Only X movement
      const dirX = playerPos.x - wizardPos.x;
      const stepSize = Math.sign(dirX) * (this.currentStep.step || this.data.approachStep);

      this.el.object3D.position.x += stepSize;

      // track distance moved
      this.travelled += Math.abs(stepSize);
      if (this.travelled >= (this.currentStep.moveDistance || 1.5)) {
        this.currentStep.moveTowardPlayer = false;
      }
    }
  },

  startReaction: function() {
    this.playLoop(this.data.getOutStartAnim);

    // Show text
    this.textEl.setAttribute('visible', true);
    this.shadowEl.setAttribute('visible', true);

    // Freeze player after short delay
    setTimeout(() => {
      if (this.player.components['player-movement'])
        this.player.components['player-movement'].pause = true;
      this.choices.setAttribute('visible', true);
    }, this.data.choiceDelay);
  },

  handleChoice: function(choice) {
    this.choices.setAttribute('visible', false);
    this.textEl.setAttribute('visible', false);
    this.shadowEl.setAttribute('visible', false);

    switch(choice) {
      case 'ignore':
        this.playSequence([
          { anim: this.data.approachAnim, moveTowardPlayer: true, moveDistance: 1.2 },
          { anim: this.data.ignoreDeathAnim, repeat: 5 }
        ], () => alert('You died! Game over.'));
        break;

      case 'getOut':
        this.playSequence([
          { anim: this.data.getOutStartAnim, moveTowardPlayer: true, moveDistance: 1.2 },
          { anim: this.data.ignoreDeathAnim, repeat: 5 }
        ], () => alert('You died! Game over.'));
        break;

      case 'explain':
        this.playSequence([{ anim: this.data.explainAnim }], () => {
          if (this.player.components['player-movement'])
            this.player.components['player-movement'].pause = false;
          this.playLoop(this.data.idleAnim);
        });
        break;
    }
  },

  playLoop: function(animName) {
    if (!this.actions[animName]) return;
    Object.values(this.actions).forEach(a => a.stop());
    const action = this.actions[animName];
    action.reset();
    action.setLoop(THREE.LoopRepeat);
    action.play();
  },

  playSequence: function(queue, callback) {
    if (!queue || queue.length === 0) { if (callback) callback(); return; }

    const step = queue.shift();
    const action = this.actions[step.anim];
    if (!action) { this.playSequence(queue, callback); return; }

    // Save current step for tick
    this.currentStep = step;
    if (step.moveTowardPlayer) {
      this.travelled = 0; // reset travelled distance
    }

    Object.values(this.actions).forEach(a => a.stop());
    action.reset();
    action.setLoop(THREE.LoopOnce);
    action.play();

    let repeats = step.repeat || 1;
    let count = 1;
    const mixer = this.mixer;

    const onFinished = () => {
      if (count < repeats) {
        count++;
        action.reset().play();
        return;
      }
      mixer.removeEventListener('finished', onFinished);
      this.currentStep = null;
      this.playSequence(queue, callback);
    };
    mixer.addEventListener('finished', onFinished);
  }
});


  AFRAME.registerComponent('ghost-behavior', {
    schema: {
      idleAnim: { type: 'string', default: 'thc3_arma|idle' },
      howlAnim: { type: 'string', default: 'thc3_arma|howl' },
      dieAnim:  { type: 'string', default: 'thc3_arma|die2' },
      attack3Anim: { type: 'string', default: 'thc3_arma|attack3' },
      attack1Anim: { type: 'string', default: 'thc3_arma|attack1' },
      attack2Anim:  { type: 'string', default: 'thc3_arma|attack2' },
      battleIdleAnim: { type: 'string', default: 'thc3_arma|battle_idle' },
      reactDistance: { type: 'number', default: 0.9 }
    },

    init: function () {
      this.player = document.querySelector('#rig');
      this.choices = document.querySelector('#ghostChoices');
      this.buttons = Array.from(this.choices.querySelectorAll('.ghost-choice'));

      this.mixer = null;
      this.actions = {};
      this.interacted = false;
      this.sequenceQueue = [];

      this.el.addEventListener('model-loaded', e => {
        const model = e.detail.model;
        if (!model) return;

        this.mixer = new THREE.AnimationMixer(model);
        const clips = model.animations || [];

        clips.forEach(c => {
          const action = this.mixer.clipAction(c);
          action.clampWhenFinished = true;
          this.actions[c.name] = action;
        });

        // Start idle
        if (this.actions[this.data.idleAnim]) {
          this.actions[this.data.idleAnim].setLoop(THREE.LoopRepeat);
          this.actions[this.data.idleAnim].play();
        }
      });

      // Hook choices
      this.buttons.forEach(btn => {
        btn.addEventListener('click', () =>
          this.handleChoice(btn.getAttribute('data-choice'))
        );
      });
    },

    tick: function (time, dt) {
      if (this.mixer) this.mixer.update(dt/1000);

      if (!this.interacted && this.mixer) {
        const playerPos = new THREE.Vector3();
        const ghostPos = new THREE.Vector3();
        this.player.object3D.getWorldPosition(playerPos);
        this.el.object3D.getWorldPosition(ghostPos);

        const dist = playerPos.distanceTo(ghostPos);
        if (dist < this.data.reactDistance) {
          this.interacted = true;
          this.startInteraction();
        }
      }
    },

    playLoop: function(animName) {
  if (!this.actions[animName]) return;

  // Stop all current animations
  Object.values(this.actions).forEach(a => a.stop());

  // Play the new one in loop
  const action = this.actions[animName];
  action.reset();
  action.setLoop(THREE.LoopRepeat);
  action.play();
},

    startInteraction: function () {
      // Switch from idle → battle_idle
      this.playLoop(this.data.battleIdleAnim);

      // Freeze player
      if (this.player.components['player-movement'])
        this.player.components['player-movement'].pause = true;

      // Show choices
      this.choices.setAttribute('visible', true);
    },

    handleChoice: function (choice) {
      this.choices.setAttribute('visible', false);

      switch(choice) {
        case 'kill':
          this.playSequence([
            { anim: this.data.howlAnim, loop: false },
            { anim: this.data.dieAnim, loop: false }
          ], () => {
            // Stay dead, unfreeze player
            if (this.player.components['player-movement'])
              this.player.components['player-movement'].pause = false;
          });
          break;

        case 'ignore':
          this.playSequence([
            { anim: this.data.attack3Anim, loop: false },
            { anim: this.data.attack2Anim, loop: false },
            { anim: this.data.attack1Anim, loop: false },
            { anim: this.data.attack3Anim, loop: false }
          ], () => {
            alert("The ghost cursed you. You died!");
          });
          break;
      }
    },

    playSequence: function(queue, callback) {
      if (!queue || queue.length === 0) {
        if (callback) callback();
        return;
      }

      const step = queue.shift();
      let action;

      if (step.anim) {
        action = this.actions[step.anim];
      } else if (step.animIndex !== undefined) {
        // Use numerical index (1,2,3...)
        const clips = this.el.getObject3D('mesh').animations || [];
        const clip = clips[step.animIndex-1];
        if (clip) {
          action = this.mixer.clipAction(clip);
        }
      }

      if (!action) {
        this.playSequence(queue, callback);
        return;
      }

      Object.values(this.actions).forEach(a => a.stop());
      action.reset();
      action.setLoop(step.loop === false ? THREE.LoopOnce : THREE.LoopRepeat);
      action.play();

      const mixer = this.mixer;
      const onFinished = () => {
        mixer.removeEventListener('finished', onFinished);
        this.playSequence(queue, callback);
      };
      mixer.addEventListener('finished', onFinished);
    }
  });


/* -----------------------
   Scatter trees
----------------------- */
(function scatterTrees(){
  const trees=document.getElementById('trees');
  if(!trees) return;
  const treeTypes=['tree1','tree2','tree3','tree4'];
  const branchTreeTypes=['tree1','tree2','tree3'];

function inPath(x, z) {
  // extended main straight path
  if (x > -1.2 && x < 1.2 && z > 10 && z < 30.5) return true;

  // cross-section near fork
  if (x > -5.5 && x < 5.5 && z > 11 && z < 12.5) return true;

  // branches
if (x > -5 && x < -1 && z > -7 && z < 10) return true; // left
if (x > -1.2 && x < 1 && z > -7 && z < 10) return true; // middle
if (x > 1.25 && x < 5 && z > -7 && z < 10) return true; // right

  // other paths
  if (x > -4.5 && x < 4.5 && z > -8.5 && z < -7) return true;
  if (x > -1.3 && x < 1.3 && z > -16 && z < -7.25) return true;

  // other special areas (house, castle, etc.)
  if (x > -3.3 && x < 3.8 && z > 27.5 && z < 33.7) return true;

// Castle exclusion
if (x > -8 && x < 7.5 && z > -30 && z < -12) return true;


  // Witch exclusion
  if (x > 1 && x < 4 && z > 3 && z < 6) return true;

  // Goblin exclusion
  if (x > 2 && x < 4 && z > -6 && z < -2) return true;

  // Fairies exclusion
  if (x > 2 && x < 5 && z > 6 && z < 8) return true;

  // Mushroom exclusion
  if (x > 2 && x < 4 && z > -1 && z < 1) return true;
  return false;
}



  for(let i=0;i<600;i++){
    let x=(Math.random()-0.5)*70, z=(Math.random()-0.5)*70;
    if(inPath(x,z)) continue;
    const type=treeTypes[Math.floor(Math.random()*treeTypes.length)];
    if (type === 'tree4' && z > -7 && z < 9) continue;
    let scale=0.01+Math.random()*0.01;
    if(type==='tree4') scale*=35; if(type==='tree3') scale*=3.5;
    const rotY=Math.random()*360;
    let tree=document.createElement('a-entity');
    tree.setAttribute('gltf-model',`#${type}`);
    tree.setAttribute('position',`${x} 0 ${z}`);
    tree.setAttribute('scale',`${scale} ${scale} ${scale}`);
    tree.setAttribute('rotation',`0 ${rotY} 0`);
    trees.appendChild(tree);
  }

  for(let i=0;i<80;i++){
    const z=-6+Math.random()*14;
    let x = Math.random()<0.5 ? -2.0+(Math.random()*1.0) : 1.0+(Math.random()*1.0);
    const type=branchTreeTypes[Math.floor(Math.random()*branchTreeTypes.length)];
    let scale=0.01+Math.random()*0.01; if(type==='tree3') scale*=3.5;
    const rotY=Math.random()*360;
    let tree=document.createElement('a-entity');
    tree.setAttribute('gltf-model',`#${type}`);
    tree.setAttribute('position',`${x} 0 ${z}`);
    tree.setAttribute('scale',`${scale} ${scale} ${scale}`);
    tree.setAttribute('rotation',`0 ${rotY} 0`);
    trees.appendChild(tree);
  }
})();

</script>
</a-scene>
</body>
</html>
