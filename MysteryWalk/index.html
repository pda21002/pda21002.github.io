<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Paths scene</title>
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
</head>
<body>
<a-scene cursor="rayOrigin: mouse" raycaster="objects: .fork-menu-button" keyboard-shortcuts="" screenshot="" xr-mode-ui="">
  <!-- Assets -->
  <a-assets>
    <img id="groundTexture" src="assets/grass.jpg">
    <img id="pathTexture" src="assets/stone.png">

    <!-- Tree models -->
    <a-asset-item id="tree1" src="assets/giant_oak_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree2" src="assets/kapok_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree3" src="assets/sequoia_redwood_tree_voxel.glb"></a-asset-item>
    <a-asset-item id="tree4" src="assets/voxel_models.glb"></a-asset-item>
  </a-assets>

  <!-- Ground (purely decorative; player cannot step off paths) -->
  <a-plane rotation="-90 0 0" width="50" height="50" material="repeat: 20 20; shader: flat; src: #groundTexture"></a-plane>

  <!-- Path geometry (visual) -->
  <!-- Intro vertical -->
  <a-box id="path_intro" width="1.5" height="0.05" depth="8" position="0 0.025 12.75" material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork horizontal -->
  <a-box id="path_fork_h" width="7" height="0.05" depth="1.5" position="0 0.03943 8.75" material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Branches -->
  <a-box id="path_left" class="branch" width="1.5" height="0.05" depth="14" position="-2.76655 0.025 1.00951" material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box id="path_middle" class="branch" width="1.5" height="0.05" depth="14" position="0 0.025 1.03888" material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>
  <a-box id="path_right" class="branch" width="1.5" height="0.05" depth="14" position="2.737 0.025 1.01381" material="repeat: 1 7; shader: flat; src: #pathTexture"></a-box>

  <!-- Ending horizontal (the one before final straight) -->
  <a-box id="path_ending_h" width="7" height="0.05" depth="1.5" position="0 0.03169 -6.25" material="repeat: 7 1; shader: flat; src: #pathTexture"></a-box>

  <!-- Final straight to castle -->
  <a-box id="path_final" width="1.5" height="0.05" depth="8" position="0 0.025 -10.75" material="repeat: 1 4; shader: flat; src: #pathTexture"></a-box>

  <!-- Fork menu (HUD) -->
  <a-entity id="forkMenu" visible="false" position="0 1.5 6">
    <a-box class="fork-menu-button" data-choice="left" position="-2 0 0" width="1" height="0.5" depth="0.2" color="blue"></a-box>
    <a-box class="fork-menu-button" data-choice="middle" width="1" height="0.5" depth="0.2" color="yellow"></a-box>
    <a-box class="fork-menu-button" data-choice="right" position="2 0 0" width="1" height="0.5" depth="0.2" color="red"></a-box>
  </a-entity>

  <!-- Castle -->
  <a-box id="castle" position="0 0.5 -15" width="2" height="2" depth="2" color="gold"></a-box>

  <!-- Player rig -->
  <a-entity id="rig" position="0 0.5 16" player-movement>
    <a-entity camera look-controls></a-entity>
  </a-entity>

  <!-- Tree container -->
  <a-entity id="trees"></a-entity>

  <script>
  /* -------------------------
     Helper geometry functions
     ------------------------- */

  function rectContains(rect, x, z) {
    // rect: { x1, x2, z1, z2 } inclusive
    return x >= rect.x1 && x <= rect.x2 && z >= rect.z1 && z <= rect.z2;
  }

  function pointInAny(pointX, pointZ, rects) {
    for (let i = 0; i < rects.length; i++) {
      if (rectContains(rects[i], pointX, pointZ)) return true;
    }
    return false;
  }

  /* -------------------------
     Path geometry (logic rectangles)
     ------------------------- */

  // These rectangles follow your visual path shapes.
  // Keep them narrow so player is forced to stay on the path planes.
  const PATHS = {
    // intro vertical (visual depth 8 @ z=12.75 so span roughly z=9..17)
    intro: { x1: -0.75, x2: 0.75, z1: 9, z2: 17 },

    // fork horizontal (thin)
    fork_h: { x1: -3.5, x2: 3.5, z1: 8, z2: 9.2 },

    // branches (each branch depth -10 .. 8.75 as in your code)
    left:   { x1: -3.25, x2: -2.0, z1: -10, z2: 8.75 },
    middle: { x1: -0.9,  x2:  0.9, z1: -10, z2: 8.75 },
    right:  { x1:  2.0,  x2:  3.25, z1: -10, z2: 8.75 },

    // ending horizontal (visual at -6.25)
    ending_h: { x1: -3.5, x2: 3.5, z1: -7.2, z2: -5.2 },

    // final straight to castle (visual center path)
    final: { x1: -0.9, x2: 0.9, z1: -15, z2: -10 }
  };

  // Entrance blockers to be used for unchosen paths (thin rectangles)
  function entranceBlockRectFor(pathName) {
    if (pathName === 'left')  return { x1: -3.5, x2: -2.0, z1: 8.3, z2: 9.2 };
    if (pathName === 'middle')return { x1: -0.9, x2: 0.9,   z1: 8.3, z2: 9.2 };
    return { x1: 2.0, x2: 3.5, z1: 8.3, z2: 9.2 }; // right
  }

  // Exit blockers near the ending horizontal that keep unchosen path exits closed
  function exitBlockRectFor(pathName) {
    if (pathName === 'left')  return { x1: -3.5, x2: -2.0, z1: -6.5, z2: -5.6 };
    if (pathName === 'middle')return { x1: -0.9, x2: 0.9,   z1: -6.5, z2: -5.6 };
    return { x1: 2.0, x2: 3.5, z1: -6.5, z2: -5.6 }; // right
  }

  /* -------------------------
     Player movement component
     ------------------------- */

  AFRAME.registerComponent('player-movement', {
    init: function () {
      this.keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
      this.choiceMade = false;
      this.chosenPath = null; // 'left'|'middle'|'right'
      this.speed = 0.06;

      // initial allowed zones = intro + fork_h (until the fork menu is used)
      this.allowedZones = [ PATHS.intro, PATHS.fork_h ];

      // blockers (rectangles) for entrances/exits of unchosen paths
      this.blockers = []; // array of rect objects

      // Listen keyboard
      window.addEventListener('keydown', e => { if (this.keys[e.key] !== undefined) this.keys[e.key] = true; });
      window.addEventListener('keyup', e => { if (this.keys[e.key] !== undefined) this.keys[e.key] = false; });

      // Fork menu click handlers (keep your UI behavior)
      document.querySelectorAll('.fork-menu-button').forEach(btn => {
        btn.addEventListener('click', () => {
          const choice = btn.getAttribute('data-choice'); // left|middle|right
          this.choiceMade = true;
          this.chosenPath = choice;
          document.getElementById('forkMenu').setAttribute('visible', false);

          // Set allowed zone to the *chosen branch* (only that branch)
          if (choice === 'left')  this.allowedZones = [ PATHS.left ];
          if (choice === 'middle')this.allowedZones = [ PATHS.middle ];
          if (choice === 'right') this.allowedZones = [ PATHS.right ];

          // Add entrance + exit blockers for the *unchosen* paths
          ['left','middle','right'].forEach(p => {
            if (p !== choice) {
              this.blockers.push( entranceBlockRectFor(p) );
              this.blockers.push( exitBlockRectFor(p) );
            }
          });

          // The ending horizontal and final straight should remain reachable from every path.
          // We will allow access to them once the player's z gets <= -6 (see tick logic).
        });
      });
    },

    tick: function (time, delta) {
      const rig = this.el;
      const camera = rig.querySelector('[camera]');
      if (!camera) return; // safeguard
      let pos = rig.getAttribute('position');

      // If fork not chosen, keep player parked at fork z and show menu
      if (!this.choiceMade && pos.z <= 8.75) {
        pos.z = 8.75;
        rig.setAttribute('position', pos);
        document.getElementById('forkMenu').setAttribute('visible', true);
        return;
      }

      // Calculate camera-relative direction vectors so arrows feel natural:
      // forward = camera forward projected onto XZ plane, right = perpendicular
      const camRotY = camera.object3D.rotation.y;
      const forward = { x: -Math.sin(camRotY), z: -Math.cos(camRotY) };
      const right   = { x:  Math.cos(camRotY), z: -Math.sin(camRotY) };

      // Input -> displacement
      let dx = 0, dz = 0;
      if (this.keys.w || this.keys.ArrowUp)    { dx += forward.x * this.speed; dz += forward.z * this.speed; }
      if (this.keys.s || this.keys.ArrowDown)  { dx -= forward.x * this.speed; dz -= forward.z * this.speed; }
      if (this.keys.d || this.keys.ArrowRight) { dx += right.x * this.speed; dz += right.z * this.speed; }
      if (this.keys.a || this.keys.ArrowLeft)  { dx -= right.x * this.speed; dz -= right.z * this.speed; }

      if (dx === 0 && dz === 0) return; // nothing to do

      const tentative = { x: pos.x + dx, z: pos.z + dz };

      // If player has already reached the merge region (z <= -6), extend allowed zones
      // to include ending horizontal and final straight so all paths can reach them.
      let currentAllowed = this.allowedZones.slice(); // copy
      if (tentative.z <= -6 || pos.z <= -6) {
        // Union: allow the chosen branch's deeper area, plus ending & final
        if (this.chosenPath === 'left')  currentAllowed.push(PATHS.left);
        if (this.chosenPath === 'middle')currentAllowed.push(PATHS.middle);
        if (this.chosenPath === 'right') currentAllowed.push(PATHS.right);
        currentAllowed.push(PATHS.ending_h);
        currentAllowed.push(PATHS.final);
      }

      // Decide whether tentative position is allowed:
      const inAllowed = pointInAny(tentative.x, tentative.z, currentAllowed);
      const hitsBlocker = pointInAny(tentative.x, tentative.z, this.blockers);

      if (inAllowed && !hitsBlocker) {
        // OK — move
        rig.setAttribute('position', { x: tentative.x, y: pos.y, z: tentative.z });
      } else {
        // Movement would enter a forbidden zone. To avoid snapping, do per-axis partial movement:
        // Try X-only then Z-only, allowing sliding along blockers/edges.
        const tryX = { x: pos.x + dx, z: pos.z };
        const tryZ = { x: pos.x, z: pos.z + dz };

        const inAllowedX = pointInAny(tryX.x, tryX.z, currentAllowed) && !pointInAny(tryX.x, tryX.z, this.blockers);
        const inAllowedZ = pointInAny(tryZ.x, tryZ.z, currentAllowed) && !pointInAny(tryZ.x, tryZ.z, this.blockers);

        if (inAllowedX && !inAllowedZ) {
          rig.setAttribute('position', { x: tryX.x, y: pos.y, z: tryX.z });
        } else if (!inAllowedX && inAllowedZ) {
          rig.setAttribute('position', { x: tryZ.x, y: pos.y, z: tryZ.z });
        } else {
          // neither axis allowed: completely blocked — do nothing (no snapping).
        }
      }
    }
  });

  /* -------------------------
     Tree scattering
     ------------------------- */

  (function scatterTrees() {
    const trees = document.getElementById('trees');
    const treeTypes = ['tree1','tree2','tree3','tree4'];

    // Function to check if a candidate location is within a path rect (with small buffer)
    function isOnPath(x, z) {
      // We'll treat main path rects as forbidden with a small buffer of 0.6 units.
      const buffer = 0.6;
      const allPaths = [ PATHS.intro, PATHS.fork_h, PATHS.left, PATHS.middle, PATHS.right, PATHS.ending_h, PATHS.final ];
      for (let r of allPaths) {
        if (x >= r.x1 - buffer && x <= r.x2 + buffer && z >= r.z1 - buffer && z <= r.z2 + buffer) return true;
      }
      return false;
    }

    // Basic random scattering across the plane, but skip where isOnPath === true
    const TOTAL = 220; // more trees overall
    let placed = 0;
    for (let i = 0; i < TOTAL && placed < TOTAL; i++) {
      let x = (Math.random() - 0.5) * 50;
      let z = (Math.random() - 0.5) * 50;
      if (isOnPath(x, z)) continue;

      const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
      let scale = 0.01 + Math.random()*0.02;
      if (type === 'tree4') scale *= 30;
      const rotY = Math.random()*360;

      let tree = document.createElement('a-entity');
      tree.setAttribute('gltf-model', `#${type}`);
      tree.setAttribute('position', `${x} 0 ${z}`);
      tree.setAttribute('scale', `${scale} ${scale} ${scale}`);
      tree.setAttribute('rotation', `0 ${rotY} 0`);
      trees.appendChild(tree);
      placed++;
    }

    // Extra cluster between the 3 paths (more trees between them, but not on the path planes).
    // Cluster bounds roughly between x=-2..2 and z=-6..8 (between forks and branches)
    const clusterCount = 80;
    for (let i = 0; i < clusterCount; i++) {
      // random inside cluster area
      const x = -2 + Math.random()*4;   // -2..2
      const z = -6 + Math.random()*14;  // -6..8
      // skip if on a path (narrow)
      if (isOnPath(x, z)) continue;

      const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
      let scale = 0.012 + Math.random()*0.015;
      if (type === 'tree4') scale *= 22;
      const rotY = Math.random()*360;

      let tree = document.createElement('a-entity');
      tree.setAttribute('gltf-model', `#${type}`);
      tree.setAttribute('position', `${x} 0 ${z}`);
      tree.setAttribute('scale', `${scale} ${scale} ${scale}`);
      tree.setAttribute('rotation', `0 ${rotY} 0`);
      trees.appendChild(tree);
    }
  })();

  </script>
</a-scene>
</body>
</html>

